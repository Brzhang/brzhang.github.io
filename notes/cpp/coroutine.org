#+TITLE: C++ coroutine
#+AUTHOR: Brook Zhang
#+DATE: 2020-12-09
#+OPTIONS: ^:nil

* 概述
#+BEGIN_QUOTE
为了提高对硬件性能的利用率(主要是CPU和IO),进一步压榨硬件性能,我们在开发中引入了下面的概念:
a. 多线程
b. 异步 IO
c. 协程
#+END_QUOTE
**  多线程
#+BEGIN_QUOTE
 多线程是一种粒度较粗的多任务机制,它能够充分利用 CPU 的多核,并行处理,提高 CPU 的利用率,但是线程并不是越多越好,我们通常以线程函数的工作内容为依据,结合物理机的 CPU 核心数,建立一个线程池.

为什么线程不是越多越好,这跟线程的特性有关系: 
+ 线程是非常耗费资源的, 首先线程的创建非常耗时,并且会给每个线程预分配一个调用栈,数量级为 MB,
+ 并且线程上下文的切换非常耗时,需要从用户态切换到内核态,保存当前线程的上下文,加载目标线程的上下文,从内核态切换到用户态.所以当就绪线程个数远大于 CPU 内核数时,大量的线程切换会导致性能急剧下降.
#+END_QUOTE
**  协程
#+BEGIN_QUOTE 协程又称为子线程或者微线程,是一种轻量级的用户态线程,协程是运行在线程之上的,在同一个线程中,协程是串行的,不会发生线程资源的竞争,不需要加锁,但是如果把同一个协程的运行块放在不同的线程中,涉及到资源竞争,则需要加锁.
 协程在同一个线程中是串行执行的,所以,协程最大的用途在于处理 IO 密集型任务,而非 CPU 密集型任务.
 
 协程的切换是在用户态进行的,上线文切换由自己控制.
#+END_QUOTE
***  实现
#+BEGIN_QUOTE
 每一个协程有一个对应的协程函数,首次调用协程函数,会从堆中分配一个协程上下文保存调用方的返回地址, 入口函数等信息,当协程中途交出控制权后,协程上下文不会被删除,当协程再次获得控制权后,自动从协程上下文中恢复调用环境,然后从上一次交出控制权的下一条语句继续执行.协程函数返回后,协程上下文将被删除.

根据实现方式不同,协程分为有栈协程和无栈协程.
#+END_QUOTE
****  有栈协程
#+BEGIN_QUOTE
一个线程可以创建多个协程,每个协程都有一个预先分配的调用栈,并且每个协程都属于且仅属于创建它的线程.

协程必须主动交出控制权,否则同一线程上的其他协程无法获得执行机会,如果协程可以把控制权交给统一线程的其他协程,则 称为对称协程(symm-etry coroutines).  若只能把控制权交给主协程(当前线程), 
主协程作为调度器,负责分配执行权,则称为非对称协程(Asymmetry coroutines).

有栈协程的实现不依赖编译器,利用系统调用即可实现.

为了减少有栈协程的空间开销,有的协程框架用一个共享栈代替每个协程的私有栈,降低了空间开销,但是增加了栈拷贝的时间开销.

+ Linux 下系统调用: getcontext, setcontext, makecontext, swapcontext.

+ Windows 下的系统调用:CreateFiber, ConvertFiberToThread, SwitchToFiber.
#+END_QUOTE

****  无栈协程
#+BEGIN_QUOTE
无栈协程的原理是将异步 IO 封装到协程函数中,协程函数发起异步 IO 后,保存执行环境,将控制权交给调用方. 异步调用完成后,负责处理 IO 完成事件的回调函数获得控制权,回调函数再把控制权交给发起 IO 的协程,协程恢复执行环境,从交出控制权的下一条语句继续执行.

无栈协程支持跨线程调用,所以需要处理资源竞争的问题.

无栈协程的执行环境,只需要保持调用栈的栈顶帧,不需要保存整个调用栈,所以空间的开销极小.

无栈协程不需要协程调度器,并且在执行路径上,只有特定语句才能交出控制权.

无栈协程需要编译器的支持.
#+END_QUOTE

** 异步IO
#+BEGIN_QUOTE
 操作系统 IO 分为同步 IO 和异步 IO.
#+END_QUOTE
**** 同步 IO: 发起 IO 后,CPU 需要等待 IO 返回后才能继续执行.
**** 异步 IO: 发起 IO 前,需要先注册一个回调函数,发起 IO 后,CPU 不需要等待 IO 返回就可以继续执行, 当收到 IO 完成的中断信号后,调用回调函数处理剩下的工作.
#+BEGIN_QUOTE
显而易见,同步 IO 逻辑简单, 但是效率较低;  异步 IO 性能好,但是实现逻辑相对复杂,适合大规模并发的场景.
#+END_QUOTE

* IO 密集型任务架构
#+BEGIN_QUOTE
 大多数后台服务的主要应用场景是 IO 密集型任务.处理流程入下:
+ a,  监听线程收到一个客户端请求
+ b,  监听线程将请求加入请求队列中,继续监听
+ c,  工作线程从请求队列中取出请求,发起 IO 处理
+ d,  IO  完成后,向客户端返回请求结果

这里的 c,d  步骤中的 IO 处理,可以是三种实现:
+ a, 同步 IO. 优点:逻辑清晰. 缺点:硬件资源利用率低 
+ b, 异步 IO. 优点:性能好,硬件资源利用率高. 缺点:异步代码逻辑复杂.
+ c, 工作线程启动协程,协程负责处理 IO,由协程向客户端返回请求结果.   优点:性能好,硬件资源利用率高. 逻辑清晰.
#+END_QUOTE
